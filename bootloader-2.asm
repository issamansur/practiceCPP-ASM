CODE_SEG equ gdt_code - gdt_start

use16 ; Указываем, что команды 16-битные
org 0x7c00 ; Начало загрузочного сектора

boot:
        mov ax, 0x2401 ; Устанавливаем значение в регистр ax
        int 0x15 ; Вызываем прерывание 0x15 (расширение BIOS)
        mov ax, 0x3 ; Устанавливаем видеорежим №3 (текстовый)
        int 0x10 ; Вызываем прерывание 0x10 (взаимодействие с видеокартой)
        cli ; Очищаем разрешение на прерывания (флаг IF)
        lgdt [gdt_pointer]; Загружаем глобальную таблицу дескрипторов
        mov eax, cr0 ; Загружаем значение в eax из регистра cr0
        or eax, 0x1 ; Устанавливаем первый бит отвечающий за защищенный режим
        mov cr0, eax ; Загружаем значение обратно в регистр cr0
        jmp dword CODE_SEG:boot2 ; Переход в код с 32-битными инструкциями

gdt_start:

gdt_null: ; Нулевой дескриптор (обязательный)
          dq 0x0 ; 8 байт

gdt_code: ; Дескриптор кода (сегмент с исполняемыми инструкциями)
          dw 0xFFFF ; Лимит
          dw 0x0 ; База
          db 0x0
          db 10011010b ; Атрибуты (права доступа и 32-битный режим)
          db 11001111b ; Атрибуты (флаги и границы)
          db 0x0

gdt_data: ; Дескриптор данных (сегмент для данных)
          dw 0xFFFF ; Лимит
          dw 0x0 ; База (начальные байты)
          db 0x0
          db 10010010b ; Атрибуты (права доступа и 32-битный режим)
          db 11001111b ; Атрибуты (флаги и границы)
          db 0x0

gdt_end:

gdt_pointer:
        dw gdt_end - gdt_start ; Указываем размер таблицы дескрипторов
        dd gdt_start ; Указываем базовый адрес таблицы

DATA_SEG equ gdt_data - gdt_start ; Вычисляем смещение сегмента данных

use32 ; Переключаемся в 32-битный режим
boot2:
        mov ax, DATA_SEG ; Загружаем смещение сегмента данных
        mov ds, ax ; Загружаем ds
        mov es, ax ; Загружаем es
        mov fs, ax ; Загружаем fs
        mov gs, ax ; Загружаем gs
        mov ss, ax ; Загружаем ss
        mov esi, hello ; Загружаем указатель на строку "Hello world!"
        mov ebx, 0xb8000 ; Загружаем адрес видеобуфера

.loop:
        lodsb ; Загружаем байт из [esi] в al и увеличиваем esi
        or al, al ; Проверяем, является ли al нулем
        jz halt ; Если al ноль, завершаем цикл
        or eax, 0x0100 ; Устанавливаем атрибуты символа (цвет)
        mov word [ebx], ax ; Записываем символ в видеобуфер
        add ebx, 2 ; Увеличиваем адрес видеобуфера на 2 байта (для следующего символа)
        jmp .loop ; Переходим в начало цикла

halt:
        cli ; Запрещаем прерывания
        hlt ; Завершаем выполнение программы

hello: db "Hello world!",0 ; Строка "Hello world!"

times 510 - ($-$$) db 0 ; Дополняем загрузочный сектор нулями до размера 510 байт
dw 0xaa55 ; Добавляем сигнатуру завершения загрузочного сектора
